{
  "hash": "0eb7a8e5fe1af8a765c47adfbf4ffaa3",
  "result": {
    "markdown": "---\ntitle: \"Reading and Exploring data\"\nexecute:   \n  enabled: true\n  error: true\n  freeze: auto\n---\n\nIn the previous chapters we started with the fundamentals of Python. Now we will continue with more practical examples of doing data analysis with Python using the Pandas library.\n\n## Libraries\n\nThe power of Python (and many programming languages) is in the libraries.\n\nA library (aka package) is a collection of files (aka python scripts) that contains **functions** that can be used to perform specific tasks. A library may also contain data. The functions in a library are typically related and used for a specific purpose, e.g. there are libraries for plotting, handling audio data and machine learning and many many more. Some libraries are built into python, but most packages need to be installed before you can use it.\n\nImportant to add: libraries are developed and maintained by other Python users. A popular library like Pandas has a large user base and the maintainers are supported by several funders, which makes it a reliable library that is updated very frequently. But this is not always the case, on the other side of the spectrum, a library can also be published once and not maintained at all.\n\n## Pandas\nThe python library [**Pandas**](https://pandas.pydata.org/about/) is a popular open-source data analysis and data manipulation library for Python which was developed in 2008. The library has some similarities with R, mainly related to the DataFrame data type that is used to handle table like datasets.\n\nPandas is widely used in data analyses and machine learning, as it provides powerful tools for data handling and manipulation. Furthermore, it integrates well with other Python libraries for data analysis, machine learning, and statistical analysis, such as NumPy, Scikit-Learn, and StatsModels. \n\nIn this first chapter we will explore the main features of Pandas related to reading and exploring a dataset. In the following chapters we will go into finding, selecting and grouping data, merging datasets and visualization. \n\nFor this purpose, we will be using data from the <a url=\"https://figshare.com/articles/dataset/Portal_Project_Teaching_Database/1314459\">Portal Project Teaching Database</a>: real world example of life-history, population, and ecological data and, occasionally, a small ad-hoc dataset to exaplain DataFrame operations.\n\n## Preliminaries\n\nBefore we start our journey into Pandas functionalities, there are some preliminary operations to run. \n\nThe Pandas library is not a built-in library of python, it needs to be installed and loaded. Installations instructions for Pandas are in the the [setup instructions](installation-and-setup.qmd) for this course. Assuming you already installed it, let's start importing the Pandas library and checking our installed version.\n\n::: {.cell tags='[]' execution_count=1}\n``` {.python .cell-code}\nimport pandas as pd\nprint(pd.__version__)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1.5.1\n```\n:::\n:::\n\n\nIt is also possible to just type `import pandas`, but we chose to give the library an 'alias': `pd`. The main reason is that we can now use functions from the library by typing `pd` instead of `pandas` (see the following line  `print(pd.__version__)`)\n\nTo be able to read the data files that we will be using, we need to specify the location of the files (also referred to as 'path'). It is best practice to specify the path relative to the main project folder, so, in order to properly read our dataset, it's important to check that we are working in the main project folder. In order to do that, we will load another library called 'os', containing all sort of tools to interact with our operating system. The function ```os.getcwd()```, returns the current working directory (cwd).\n\n::: {.cell tags='[]' execution_count=2}\n``` {.python .cell-code}\nimport os\ncwd = os.getcwd()\nprint(cwd)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nC:\\Users\\Moope001\\OneDrive - Universiteit Utrecht\\Documents\\programming\\workshop-introduction-to-python\\book\n```\n:::\n:::\n\n\nIf the current working directory ends with `<...>/workshop-introduction-to-python`, where `<...>` is whatever directory you chose to download and unzip the course material, you are in the right place.\nIf not, use `os.chdir(<...>)` to change the working directory, where `<...>` is the full path of the `workshop-introductions-to-python` directory.\n\nLet's store the relative path of our data into a variable and let's check if the data file actually exists using the function ```os.path.exists()```\n\n::: {.cell tags='[]' execution_count=3}\n``` {.python .cell-code}\ndata_file = '../course_materials/data/surveys.csv'\nprint(os.path.exists(data_file))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrue\n```\n:::\n:::\n\n\nIf the result is True, we are all set up to go!\n\n## Reading data\n\nThe very first operation we will perform is loading our data into a Pandas **DataFrame** using ```pd.read_csv()```. \n\n::: {.cell tags='[]' execution_count=4}\n``` {.python .cell-code}\nsurveys_df = pd.read_csv(data_file)\n\nprint(type(data_file))\nprint(type(surveys_df))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<class 'str'>\n<class 'pandas.core.frame.DataFrame'>\n```\n:::\n:::\n\n\nPandas can read quite a large variety of formats like the *comma-separated values* (CSV) and Excel file formats.\n\nSometimes values in CSV files are separated using \";\" or tabs. The default separator Pandas expects is a comma, if it is different it is necessary to specify the separator in an argument, e.g.: `pd.read_csv(data_file, sep=\";\")`. The documentation of pandas provides a [full overview](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_csv.html) of the arguments you may use for this function.\n\nIn Jupyter Notebook or Jupyter Lab you can visualise the DataFrame simply by writing its name in a code cell and running the cell (in the same way you would display the value of any variable). Let's have a look at our just created DataFrame:\n\n::: {.cell tags='[]' execution_count=5}\n``` {.python .cell-code}\nsurveys_df\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>record_id</th>\n      <th>month</th>\n      <th>day</th>\n      <th>year</th>\n      <th>plot_id</th>\n      <th>species_id</th>\n      <th>sex</th>\n      <th>hindfoot_length</th>\n      <th>weight</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>1</td>\n      <td>7</td>\n      <td>16</td>\n      <td>1977</td>\n      <td>2</td>\n      <td>NL</td>\n      <td>M</td>\n      <td>32.0</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>2</td>\n      <td>7</td>\n      <td>16</td>\n      <td>1977</td>\n      <td>3</td>\n      <td>NL</td>\n      <td>M</td>\n      <td>33.0</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>3</td>\n      <td>7</td>\n      <td>16</td>\n      <td>1977</td>\n      <td>2</td>\n      <td>DM</td>\n      <td>F</td>\n      <td>37.0</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>4</td>\n      <td>7</td>\n      <td>16</td>\n      <td>1977</td>\n      <td>7</td>\n      <td>DM</td>\n      <td>M</td>\n      <td>36.0</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>5</td>\n      <td>7</td>\n      <td>16</td>\n      <td>1977</td>\n      <td>3</td>\n      <td>DM</td>\n      <td>M</td>\n      <td>35.0</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>...</th>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n    </tr>\n    <tr>\n      <th>35544</th>\n      <td>35545</td>\n      <td>12</td>\n      <td>31</td>\n      <td>2002</td>\n      <td>15</td>\n      <td>AH</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>35545</th>\n      <td>35546</td>\n      <td>12</td>\n      <td>31</td>\n      <td>2002</td>\n      <td>15</td>\n      <td>AH</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>35546</th>\n      <td>35547</td>\n      <td>12</td>\n      <td>31</td>\n      <td>2002</td>\n      <td>10</td>\n      <td>RM</td>\n      <td>F</td>\n      <td>15.0</td>\n      <td>14.0</td>\n    </tr>\n    <tr>\n      <th>35547</th>\n      <td>35548</td>\n      <td>12</td>\n      <td>31</td>\n      <td>2002</td>\n      <td>7</td>\n      <td>DO</td>\n      <td>M</td>\n      <td>36.0</td>\n      <td>51.0</td>\n    </tr>\n    <tr>\n      <th>35548</th>\n      <td>35549</td>\n      <td>12</td>\n      <td>31</td>\n      <td>2002</td>\n      <td>5</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>NaN</td>\n    </tr>\n  </tbody>\n</table>\n<p>35549 rows Ã— 9 columns</p>\n</div>\n```\n:::\n:::\n\n\nBy looking at the DataFrame we can finally understand what a DataFrame actually is: a 2-dimensional data structure storing different types of variables in columns. All rows in the DataFrame have a row index (starting from 0). The columns have names. The row indices and column names can be used to do operations on values in the column (we will go into this later). \n\nAs you can see Jupyter only prints the first and last 5 rows separated by `...` . In this way the notebook remains clear and tidy (printing the whole DataFrame may result in a large table and a lot of scrolling to get to the next code cell).\n\nIt is, however, enough for a quick exploration of how the dataset looks like in terms of columns names, values, and potential reading errors.\n\n<div class=\"alert alert-block alert-success\">\n<b>Exercise 1</b>\n    \nNow go to the Jupyter Dashboard in your internet browser and open the notebook `afternoon_exercises.ipynb` and do exercise 1.\n</div>\n\n::: {.callout-note}\nAs you can see in this exercise a DataFrame object comes with several methods that can be applied to the DataFrame. A method is similar to a function, but it can only be applied to the object it belongs to and has a different notation than a function.\n\nCompare the notation of the function `len`: `len(surveys_df)`  \nwith the DataFrame specific method `shape`: `surveys_df.shape`\n:::\n\n## Exploring data\n\nNow we will take a closer look into the actual values in the DataFrame. In order to do this it is helpful to have the column names at hand (easy for copy-pasting):\n\n::: {.cell tags='[]' execution_count=6}\n``` {.python .cell-code}\nprint(surveys_df.columns)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIndex(['record_id', 'month', 'day', 'year', 'plot_id', 'species_id', 'sex',\n       'hindfoot_length', 'weight'],\n      dtype='object')\n```\n:::\n:::\n\n\nAs you can see this gives you more information than just the column names. It is also possible to just print the column names using a for loop (see [chapter 4](Introduction_to_python_4.ipynb)):\n\n::: {.cell tags='[]' execution_count=7}\n``` {.python .cell-code}\nfor column in surveys_df.columns:\n    print(column)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nrecord_id\nmonth\nday\nyear\nplot_id\nspecies_id\nsex\nhindfoot_length\nweight\n```\n:::\n:::\n\n\nLet's select the column *weight* in our DataFrame and let's run some statistics on it\n\n::: {.cell tags='[]' execution_count=8}\n``` {.python .cell-code}\nsurveys_df['weight']\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\n0         NaN\n1         NaN\n2         NaN\n3         NaN\n4         NaN\n         ... \n35544     NaN\n35545     NaN\n35546    14.0\n35547    51.0\n35548     NaN\nName: weight, Length: 35549, dtype: float64\n```\n:::\n:::\n\n\nNow let's plot the values in a histogram:\n\n\n::: {.cell tags='[]' execution_count=9}\n``` {.python .cell-code}\nsurveys_df['weight'].plot(kind='hist')\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\n<Axes: ylabel='Frequency'>\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](data-science-with-pandas-1_files/figure-html/cell-10-output-2.png){width=610 height=411}\n:::\n:::\n\n\nDid you notice how easy it was to obtain a summary plot of a column of our DataFrame? We can repeat the same for every column with a single line of code.\n\n::: {.cell tags='[]' execution_count=10}\n``` {.python .cell-code}\nsurveys_df['hindfoot_length'].plot(kind='hist')\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\n<Axes: ylabel='Frequency'>\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](data-science-with-pandas-1_files/figure-html/cell-11-output-2.png){width=610 height=411}\n:::\n:::\n\n\nWe can also make quick scatterplots to explore the relation between two columns:\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\n%matplotlib inline # what this does will be discussed in the last chapter about visualization\nax1 = surveys_df.plot(x='weight', y='hindfoot_length', kind='scatter')\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nUsageError: unrecognized arguments: # what this does will be discussed in the last chapter about visualization\n```\n:::\n:::\n\n\n<div class=\"alert alert-block alert-success\">\n<b>Exercise 2</b>\n    \nNow go to the Jupyter Dashboard in your internet browser and continue with exercise 2.\n</div>\n\nInstead of running the methods above one by one, we can obtain a statistical summary using the method ```.describe()```. Let's get a statistical summary for the weight column.\n\n::: {.cell tags='[]' execution_count=12}\n``` {.python .cell-code}\nsurveys_df['weight'].describe()\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\ncount    32283.000000\nmean        42.672428\nstd         36.631259\nmin          4.000000\n25%         20.000000\n50%         37.000000\n75%         48.000000\nmax        280.000000\nName: weight, dtype: float64\n```\n:::\n:::\n\n\nThere are many more methods that can be used. For a complete overview, check out the [documentation of Pandas](https://pandas.pydata.org/pandas-docs/stable/reference/frame.html).\nSome useful ones are the `unique` method to display all unique values in a certain column:\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\nsurveys_df['species_id'].unique()\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\narray(['NL', 'DM', 'PF', 'PE', 'DS', 'PP', 'SH', 'OT', 'DO', 'OX', 'SS',\n       'OL', 'RM', nan, 'SA', 'PM', 'AH', 'DX', 'AB', 'CB', 'CM', 'CQ',\n       'RF', 'PC', 'PG', 'PH', 'PU', 'CV', 'UR', 'UP', 'ZL', 'UL', 'CS',\n       'SC', 'BA', 'SF', 'RO', 'AS', 'SO', 'PI', 'ST', 'CU', 'SU', 'RX',\n       'PB', 'PL', 'PX', 'CT', 'US'], dtype=object)\n```\n:::\n:::\n\n\nOr ```.nunique()``` to return the number of unique elements in a column. \n\n::: {.cell tags='[]' execution_count=14}\n``` {.python .cell-code}\nprint(surveys_df['plot_id'].nunique())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n24\n```\n:::\n:::\n\n\nPerhaps we want to get some insight into the values for certain species or plots, in the next chapter we will go into [making groups and selections](data-science-with-pandas-2.ipynb).\n\n",
    "supporting": [
      "data-science-with-pandas-1_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}